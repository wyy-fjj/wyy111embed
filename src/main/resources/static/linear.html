<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <title>数据结构--线性表</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css">
    <link rel="stylesheet" href="../static/css/typo.css">
    <link rel="stylesheet" href="../static/lib/prism/prism.css">
    <link rel="stylesheet" href="../static/lib/tocbot/tocbot.css">
    <link rel="stylesheet" href="../static/css/me.css">
    <style>
        p{
            text-indent: 2em !important;
        }
    </style>
</head>
<body>
<!--导航-->
<nav class="ui inverted attached segment m-padded-tb-mini m-shadow-small">
    <div class="ui container">
        <!--为了适应手机端查看页面，添加stackable属性，代表可堆叠，给grid之前加上stackable-->
        <div class="ui inverted secondary stackable menu">
            <h2 class="ui red header item">数据结构大学堂</h2>
            <a href="#" class="active m-item item m-mobile-hide"><i class="mini file icon"></i>线性表</a>

            <a href="#" class="m-item item m-mobile-hide"><i class="mini file icon"></i>查找算法</a>
            <a href="#" class="m-item item m-mobile-hide"><i class="mini file icon"></i>树</a>
            <a href="#" class="m-item item m-mobile-hide"><i class="mini file icon"></i>图</a>
            <a href="#" class="m-item item m-mobile-hide"><i class="mini file icon"></i>排序算法</a>
            <div class="right m-item item m-mobile-hide">
                <!-- transparent搜索框显示为透明 inverted颜色反转 -->
                <div class="ui icon inverted white input">
                    <input type="text" placeholder="搜索">
                    <i class="search link icon"></i>
                </div>
            </div>
        </div>
    </div>
    <!--点击再显示，加一个图标  menu toggle只是为了使用，另一种方法也可以用id  -->
    <a href="#" class="ui menu toggle black icon button m-right-top m-mobile-show">
        <i class="sidebar icon"></i>
    </a>
</nav>

<!--中间内容-->

<div  class="m-container-small m-padded-tb-big">
    <div class="ui container">
        <div class="ui top attached segment">
            <!--头部-->
            <div class="ui  horizontal link list">
                <div class="item">
                    <img src="https://picsum.photos/id/1015/100/100" alt="" class="ui avatar image">
                    <div class="content"><a href="#" class="header">王煜仪</a> </div>
                </div>
                <div class="item">
                    <i class="calendar icon"></i>2020-08-15
                </div>
                <div class="item">
                    <i class="eye icon"></i>86
                </div>
            </div>
        </div>
        <div class="ui attached padded segment">
            <!--内容部分-->
            <div class="ui right aligned basic segment">
                <div class="ui orange basic label">线性表--知识点整理</div>
            </div>
            <h1 class="ui center aligned header">线性表（一对一）</h1>
            <br>
            <div id="content" class="typo typo-selection js-toc-content  m-padded-lr-responsive m-padded-tb-large">
                <h2 id="section1">一、线性表特点 </h2>
                <p>1.同一性（数据类型一致）</p>
                <p>2.有限性（元素个数有限））</p>
                <p>3.有序性</p>
                <h2>二、顺序表</h2>
                <p>顺序表是以一组地址连续的存储单元依次存储数据元素的线性表。称为线性表的顺序存储结构或顺序映像 （sequential
                    mapping）。它以“物理位置相邻”来表示线性表中数据元素间的逻辑关系，可随机存取表中任一元素。</p>
                <h4>2.1顺序表初始化</h4>
                <p>一般模板定义为：</p>
                <pre><code class="language-css">
              typedef struct *list L
                struct list{
                    Element data[maxsize];
                    int length;
                };
                list l;
                L p;
                </code></pre>
                <h4>2.2顺序表操作</h4>
                <p>（1）查找：顺序表的查找分为按序号查找和按元素值查找。</p>
                <p>（2）插入：在数组第i个位置插入一个新元素，需要从最后一个元素逐一向后移动。</p>
                <p>（3）删除：删除第i个元素，顺序表长度减1，从i+1个元素开始向前移动。</p>
                <h4>2.3顺序表优缺点</h4>
                <p>（1）逻辑上相邻的两个元素物理上也相邻；</p>
                <p>（2）存储位置可以通过公式计算；</p>
                <p>（3）需要分配较大空间；</p>
                <p>（4）做插入、删除时需要移动大量元素</p>
                <p>（5）表的容量难以扩充。</p>
                <h2>三、链表</h2>
                <p>链表是物理地址上不连续，数据元素的逻辑顺序通过链表中的指针链接次序实现。</p>
                <h4>3.1链表初始化</h4>
                <p>一般模板定义为：</p>
                <pre><code class="language-css">
          typedef struct node* list;
            Struct node{
                ElementType Data;
                List next;
            };
            Strcut node L;
            list p;

                </code></pre>
                <h4>3.2链表操作</h4>
                <p><b>链表的结点包含自身的数据（value）和下一个结点的地址。</b></p>
                <p>（1）查找：链表的查找需要遍历链表 主要语句:p = p->next</p>
                <p>（2）插入：要插入第i个位置时，先构造一个新结点，用s指向该结点，找到第i-1个位置，将p指向i-1结点，然后执行如下语句：s->data = X;s->next = p->next;p->next = s;</p>
                <p>（3）删除：要删除第i个结点，首先新建一个s结点，然后找到第i-1个结点位置，然后执行如下语句：s = p-> next; p->next = s ->next; x=s->data; free(s).</p>
                <h4>3.3单链表的前插法和后插法</h4>
                <p>1.前插法</p>
                <p>每次都把新节点作为链表的第一个结点插入，首先建立一个带头结点的空单链表，L= new node; L->next = NULL;再创建一个s结点：s = new node; s->data = x；s->next = L->next; L-next = s;</p>
                <p>2.后插法</p>
                <p>每次都把新节点作为链表的最后一个结点插入，首先建立一个新节点s，找到尾结点r，s = new node; s->data = x; s-> next = NULL ;r->next = s;</p>
                <p>如下为单链表、双向链表和静态单链表存储结构</p>
                <pre class="language-css"><code class="language-css">
              // --- 线性表的单链表存储结构 ---
                  typedef struct LNode{
                  ElemType     data;
                  struct LNode *next;
                  }LNode, LinkList;

            // --- 线性表的双向链表存储结构 ---
            typedef struct DuLNode{
                ElemType       data;
                struct DuLNode *prior, *next;
            }DuLNode, DuLinkList;

            // --- 线性表的静态单链表存储结构 ---
            # define MAXSIZE 100
            typedef struct{
                ElemType data;
                int      cur;
            }component, SLinkList[MAXSIZE];</code></pre>

                <h4>3.4线性表的主要操作算法设计与实现</h4>
                <h4>3.4.1 初始化线性表</h4>
                <pre class="language-css"><code class="language-css">
    Status InitList_Sq(SqList *L){
    // 创造一个空的线性表L
    L->elem = (ElemType *)malloc(LIST_INIT_SIZE * sizeof(ElemType));
    if (! L->elem) exit(OVERFLOW);  // 存储分配失败
    L->length = 0;                  // 空表长度为0
    L->listsize = LIST_INIT_SIZE;   // 初始存储容量
    return OK;
}</code></pre>
                <h4>3.4.2 创建单链表</h4>
                <pre class="language-css"><code class="language-css">
    LinkList *CreateList_L(int n){
        // 逆序输入 n 个元素的值，建立带表头结点的单链表 L
        LinkList *L, *p; int i;
        L = (LinkList *)malloc(sizeof(LNode));
        L->next = NULL;                 // 先建立一个带头结点的单链表
        for(i=n; i>0; --i){
            p = (LNode *)malloc(sizeof(LNode));  // 生成新结点
            p->data = random(200);               // 填入随机数
            p->next = L->next; L->next = p;      // 插入到表头
        }
        return L;
    }</code></pre>
                <h4>3.4.3 双向循环链表插入元素</h4>
                <pre class="language-css"><code class="language-css">
    Status ListInsert_DuL(DuLinkList *L, int i, ElemType e){
    DuLinkList *p, *q;  int j;
    if(i<1) return ERROR;
    p = L;  j = 0;
    while(p->next!=L && j<i-1){  // 在 L 中确定插入位置
        p = p->next;  j++;
    }
    if(p->next!=L || (p->next==head&&j==i-1)){
        q = (DuLinkList*)malloc(sizeof(DuLinkList));
        q->data = e;
        q->next = p->next;  q->prior = p;
        p->next->prior = q;  p->next = q;
        return OK;
    }
    else return ERROR;
}</code></pre>

                <h2>四、队列</h2>
                <p>队列是一种线性数据结构，一段插入，另一端删除，满足数据元素先入先出和后入后出的操作，允许插入的一段叫队尾，允许删除的一端叫队头。</p>
                <p>4.1 队列的特点</p>
                <p>(1)新元素总是加入到队尾</p>
                <p>(2)每次删除的元素总是再对头</p>
                <p>(3)先进先出</p>
                <p>4.2 应用案例</p>
                <p>(1)硬件设备的排队：打印机</p>
                <p>(2)缓冲区的循环使用</p>
                <p>(3)操作系统的资源调度算法</p>
                <p>4.3 队列的存储</p>
                <p>按存储分类：顺序队列、链式队列</p>
                <p>1.链式队列</p>
                <p>设置了两个指针变量front和rear，分别指向队列的头和尾。</p>
                <p>2.顺序队列</p>
                <p>判断队列为空的条件 front == rear；</p>
                <p>判断队列为满的条件 rear = MAXSIZE；</p>
                <h2>五、堆栈</h2>
                <p>5.1 栈的特点</p>
                <p>只在一端做插入和删除，即后入先出。</p>
                <p>5.2 堆栈的存储</p>
                <p>顺序栈</p>
                <pre><code class="language-css">
typedef struct{
	Element *elem;
	int top;
}sqstack;
入栈：s.top++; s.elem[s.top] = x;
出栈：s.elem[s.top];s.top--;
链栈
Typedef struct SNode *stack;
Struct SNode{
	ElementType Data;
	Struct SNode *next;
}
入栈：p->Element = X; p->next = head-> next; head->next = p;
出栈：first = head->next; head->next = first->next; X = first->Element; free(first);

                </code></pre>
                <h2>六、串与广义表</h2>
                <p>6.1 串的存储表示</p>
                <pre><code class="language-css">
#define chunksize = 80;
Typedef struct chunk{
	Char ch[maxsize];
	Struct chunk *next;
}chunk;
Typedef struct {
	Chunk *head ,*tail;
	Int curlen;
}Lstring;
                </code></pre>
                <p>6.2 广义表的特点</p>
                <p>（1）广义表中的元素可以时单元素也可以是表元素；<br><p>
                （2）广义表可以看作是线性表的推广。<br><p>
                （3）有长度（表中元素个数）；<br><p>
                （4）有序性；<br><p>
                （5）有深度：括号重数；<br><p>
                （6）可共享：可以被其他表所共享；<br><p>
                （7）可递归：自己可以作为自己的子表。
            </p>


                <div class="ui attached positive message ">
                    <!--博客信息说明-->
                    <div class="ui middle aligned grid">
                        <div class="eleven wide column">
                            <ui class=" list">
                                <li>作者：王煜仪</li>
                                <li>发表时间：2020-08-15</li>
                                <li>版权声明：自由转载-非商用</li>
                                <li>邮箱联系：876047356@qq.com</li>
                            </ui>
                        </div>
                        <div class="five wide column">
                            <img src="../static/images/2.png" alt="" class="ui right floated rounded bordered image" style="width: 130px">
                        </div>
                    </div>
                </div>
                <div id="comment-container" class="ui bottom attached segment">
                    <!--留言区域列表-->
                    <div class="ui teal segment">
                        <div class="ui comments">
                            <h3 class="ui dividing header"><trans oldtip="Comments" newtip="评论">Comments</trans></h3>
                            <div class="comment">
                                <a class="avatar">
                                    <img src="https://picsum.photos/id/1008/200/200">
                                </a>
                                <div class="content">
                                    <a class="author"><trans oldtip="wangwu" newtip="王五">王五</trans></a>
                                    <div class="metadata">
                                        <span class="date"><trans oldtip="Today at 2：38PM" newtip="今天下午2：38">Today at 2：38PM</trans></span>
                                    </div>
                                    <div class="text"><trans oldtip=" good article！ " newtip="顶！"> great! </trans></div>
                                    <div class="actions">
                                        <a class="reply">回复</a>
                                    </div>
                                </div>
                            </div>

                        </div>
                        <div class="ui form">
                            <div class="filed">
                                <textarea name="content" placeholder="请输入评论信息..."></textarea>
                            </div>
                            <div class="fields">
                                <div class="field m-mobile-wide m-margin-bottom-small">
                                    <div class="ui left icon input">
                                        <i class="user icon"></i>
                                        <input type="text" name="nickname" placeholder="姓名">
                                    </div>
                                </div>
                                <div class="field m-mobile-wide m-margin-bottom-small">
                                    <div class="ui left icon input">
                                        <i class="mail icon"></i>
                                        <input type="text" name="email" placeholder="邮箱">
                                    </div>
                                </div>
                                <div class="field m-mobile-wide m-margin-bottom-small">
                                    <button class="ui blue button m-mobile-wide m-margin-bottom-small"><i class="edit icon"></i> 发布</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div   class="m-padded m-fixed m-right-bottom "  >
                <div class="ui vertical icon buttons ">
                    <button type="button" class="ui toc blue button">目录</button>
                    <a href="#comment-container" class="ui blue button">留言</a>
                    <button type="button" class="ui wechat icon button"><i class="weixin icon"></i> </button>


                    <a href="#" class="ui icon button"><i class="chevron up icon"></i></a>
                    <!--直接返回顶部修改为平滑滚动到顶部-->
                    <!--<div id="toTop-button" class="ui icon button"><i class="chevron up icon"></i> </div>-->
                </div>
                <!--生成二维码  将已经写死的二维码注释掉，既可以随机生成二维码-->
                <div id="qrcode" class="ui wechat-qr flowing popup transition hidden " style="width: 130px !important;">
                    <!--
                      <div id="qrcode" class="ui wechat-qr flowing popup transition hidden m-padded-mini" style="width: 130px !important;">
                      <img src="images/wechat.jpg" alt="" class="ui rounded image "  style="width:120px !important;">
                    -->
                </div>
            </div>
            <!--生成目录-->
            <div class="ui toc-container flowing popup  transition hidden" style="width:250px !important;">
                <ol class="js-toc">

                </ol>
            </div>



            <script src="https://cdn.jsdelivr.net/npm/jquery@3.2/dist/jquery.min.js"></script>
            <script src="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.js"></script>
            <!--<script src="//cdn.jsdelivr.net/npm/jquery.scrollto@2.1.2/jquery.scrollTo.min.js"></script>-->

            <script src="..//static/lib/prism/prism.js"></script>
            <script src="..//static/lib/tocbot/tocbot.min.js"></script>
            <script src="..//static/lib/qrcode/qrcode.min.js"></script>

            <script>


                //item使用其来引用到m-mobile-hidden  用以判断显示display
                $('.menu.toggle').click(function () {
                    $('.m-item').toggleClass('m-mobile-hide');
                });
                //通过CSS定位到相应区域
                $('#payButton').popup({
                    popup: $('.payQR.popup'),
                    on:'click',
                    position:'bottom center',
                });
                //初始化
                tocbot.init({
                    // Where to render the table of contents.显示目录的区域
                    tocSelector: '.js-toc',
                    // Where to grab the headings to build the table of contents.生成目录的源，内容
                    contentSelector: '.js-toc-content',
                    // Which headings to grab inside of the contentSelector element. 生成目录的级别
                    headingSelector: 'h1, h2, h3',
                });
                //鼠标移入微信图标后出现二维码
                $('.wechat').popup({
                    popup: $('.wechat-qr.popup'),
                    position:'left center',
                });
                $('.toc.button').popup({
                    popup: $('.toc-container.popup'),
                    on:'click',
                    position:'left center',
                });
                //生成二维码的js代码  test 为二维码承载元素的id
                var qrcode = new QRCode("qrcode", {
                    text: "http://jindo.dev.naver.com/collie",
                    width: 110,
                    height: 110,
                    colorDark : "#000000",
                    colorLight : "#ffffff",
                    correctLevel : QRCode.CorrectLevel.H
                });
                //平滑滚动插件  失败
                /*$('#toTop-button').click(function(){
                      $(window).scrollTo(0,500);
                });*/

            </script>
</body>
</html>